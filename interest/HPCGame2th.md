# PKUHPCGame2th 北京大学高性能计算大赛第二届

我在2025年1月20日至25日参加了这个比赛(利用晚上时间)，下面的记录来自于26日晚上写的WriteUp，原本是Latex，现在改成了Markdown。

## 前言
这是我第一次参加HPCGame。在开始之前，我的HPC知识完全来自于数学学院开设的《并行与分布式计算基础》(并分基)的课程,所以没有想到还可以获得写这个WriteUp的机会。
		
下面我们每一个题目的WriteUp都按照“最终代码思路”--“做题的坎坷过程”--“总结”来进行。同时，我经过与大模型DeepSeek交流写出来的部分会有提到，并且把截图放在了一并提交的文件夹“参考”下(只截了有用的)。过程中的代码放在了文件夹code下(不过有些没留,您如果需要完全可以看我的提交记录,应该更全一点)。
	
## 在开始做题之前
点击"报名"按钮报名参赛，但是我点了若干次也没有成功。于是点击"问题反馈"，加入选手群，获得了老师的帮助，成功报名。(谢谢老师!)
	
## 签到 
非常考察眼力(当然也和我没有通读就在找4个数有一定关系).下面我们列出四句话:
	
答案的第一位是1
	
second number is eight
	
叁：9
	
最后一个是八
	
于是提交1898即可。这个绝对是我唯一一个一次AC的了。
	
## 小北问答
	
### 鸡兔同笼

有超线程的大核有两个逻辑核心，没有超线程的小核只有一个逻辑核心;而且他们都是恰有一个物理核心。口算鸡兔同笼知道有4个大核8个小核。
	
### 编程语言
	
答案是否，因为“void ** 和 const void ** 是不兼容的”。这个是通过Deepseek确定的。
	
### CPU Architecture
	
在知乎文章(网址:“https://zhuanlan.zhihu.com/p/490176486”)中有讲。最短和最长分别是128和2048。
	
### MISC
	
这个题目我试了两次才对。首先我们查到fp4是一个符号位，两个指数位，一个尾数位。两个指数位说明指数可以为2,1,0,-1,一个尾数位说明尾数可以为1.1或1.0(二进制),我第一次以为是0.1或0.0。于是正确答案是最大6,最小0.5。
	
### 储存
	
这个实在不会，直接拷打大模型。答案是ABCE。
	
### OpenMPI
	
这个不能问大模型，自己去官网("https://www.open-mpi.org/")上找。最后结论是5.0.6 3.0.7。注意5.0.7版本2025年1月16号发布，但不是稳定版本，不算答案。
	
### RDMA
	
这个倒是不难。第一列全是IB，肯定是D(InfiniBand);第二三两列基本一样，三比二多替换了一些，所以是A(Roce)和B(Rocev2),最后一列把第一行换成“iWARP”了，肯定是C了。所以答案是DABC。
	
### HPCKit
	
直接问大模型，不过有一些是可以自己看出来的。bisheng是编译器(这个后面也还会再遇到)；HMPI中有Message Processing所以是通信；KBLAS有BLA,绝对是线性代数工具，最后一个排除法。
	
### CXL
	
这个题目这个题目感觉有点歧义，不过用提交次数试一试就行了。传统架构,1GB传输需要0.1s，处理需要$0.1s$,延时$50\mu s$,一共$200.05ms$.CXL架构,1GB需要处理需要$0.1s$,延时$10\mu s$，一共$100.01ms$。由此加速比2.0。
	
### 量子计算
	
不了解基本概念，所以找了篇[知乎文章](https://zhuanlan.zhihu.com/p/599017649?utm_id=0)。了解基本概念就不用多说了。最后是0.5和1。不过1写成小数形式还是1，不是1.0。
	
## 不简单的编译
	
这道题我只会在baseline上小敲小打。
	
首先，在intel的处理器上当然要用intel的编译器。然后看到baseline在计算卷积的时候使用很多for循环因此自然而然地加入omp的并行，使用omp parallel for 和 simd 就可以达到差不多88分。
	
对应的,CMakeLists.txt也需要改一改,把\${OpenMP-CXX-FLAGS}的tag加上。前面的减号应为下划线。
	
除此之外，我还尝试过了解使用fourier变换计算卷积，但想来这种方法应该满足不了精度的要求，所以没有尝试。在最后一天的时候我有尝试过把F90程序真的写成Fortran的omp，但是ce了，遂放弃。
	
## 最长公共子序列
	
这个问题数算都讲过，应该是动态规划方法，构建一个表dp[i][j]。我最一开始的想法是按照行来并行，或者说对于一个i，让所有的j同时计算dp[i][j]。这个方法的错误非常明显，但是25分让我忽略了这一点。以至于走了很多弯路。
	
后来意识到同一行的数据之间存在数据依赖，所以改用对角线并行。注意一下对角线的种类需要分为三类(行列个数相等时只需要两类)即可。不过最后也就88分，但我已经知足了。
	
其实在过程中，我还翻看过陈国良老先生的并行算法书，其中有讲一个算法，但是我没有看明白，遂放弃。

## 着火的森林
	
这个问题的代码思路很简单，就是把森林切割成若干块，每一块都分别去模拟着火的过程。但是一定要注意，分块的时候的这些块们的边界上如何处理。
	
一种办法是让这些块们有重复，但是是在不好实施消息传递这一步，也不方便进行块的分配。所以我们让这些块们不重不漏(都是n列,在行上划分)，最后将每一块最左边的一列传递给左边的块，最右边的一列传递给右边的块。就可以了，注意两边的块的对应侧需要置零。
	
等到输出的时候却总是出现“行们倒是没什么问题，但是输出的行的顺序不对头”，后来发现忘了把所有的块的内容都传到0号进程了。
	
## 雷方块
	
这个题我只得了10分，但还是想写两句。道理就是使用列主元高斯消去法，但是矩阵实在是太大了后面。同时，如果用朴素的高斯消去法，很快就会出问题，所以必须列主元。但是列主元的话不能够保证延续“分块三对角”的好性质。所以我也不知道这个题目该怎么存储，怎么使用高斯消元法。
	
## TopK
	
这个题目一开始的时候就是通过递归分治的方法，得到了前面的基本分值。后来看到提示里面提到基数排序，于是研究了很久，但是仍然得不到多少分。
	
突然想起来学习数据结构与算法的时候老师讲的堆排序:基数排序也是基本把所有的数都排序排完了才能选出前K各元素，而堆排序不需要。所以我们并行的构建了若干个堆，利用julia的包DataStructure(我们在impl.jl里面安装这个包)里面heap的用法，就可以实现一个topK算法，最后得了180分左右。
	
这当中通过deepseek学习了julia的多线程操作和BinaryHeap的操作。
	
## Posit GEMM

看大佬都没做出来，我就直接没做。
	
## 刀锐奶化
	
想法很简单，把大规模的计算挪到GPU上去。所以定义了--global-- compute-intenstiy函数和 --device-- compute-increment函数来进行整个矩阵的计算和三角函数的计算。
	
最后得分16分。看到提示，并且询问了deepseek之后，意识到应该减小计算精度，可是我把类型变成了float，并且把计算三角函数改为使用--sincosf。可是提交之后告诉我误差是允许误差的10000倍。不知道是这个方法的问题还是我哪里写错了呜呜。
	
## HPL-MxP
	
这个题目试了很多次如何使用鲲鹏处理器的毕昇编译器都没有成功，就只好使用gcc。得了16分，后来好不容易搞明白怎么用了，竟然还不如gcc。
	
其实我干的事情就是给部分代码加上了omp的并行，又在Makefile里面添加了很多的优化选项，然后没了。
	
## 画板(靓号生成器)
	
这个题目把baseline下下来，我也没有细想，就直接把它的十个任务分配给了不同线程，然后只得到了一点点分数。
	
后来仔细地读了读代码，发现代码其实就是在干一件事情:猜。通过猜来找到靓号。所以我们应该让不同的线程一起来猜10个任务，只要每一个任务都有一个线程猜到了就可以收工了。本体其实不难。
	
## EDA
	
这个题目我总是有一个困惑，我看代码似乎并没有调用除了flute之外的不是main的函数，这真是奇怪。
	
在intel环境下，把baseline一交，在flags里面加上 -O3 和 -fopenmp 就可以有10分。
	
然后我就是简单的omp并行了一下里面的东西，就是13分。还有尝试过把里面的flute挪到gpu上用cuda算，但是后来感觉太麻烦放弃了，其实这个或许是正道。